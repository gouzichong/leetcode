# Leetcode 218
    class Solution {
    public:
        struct Node{
            int x;
            int height;
            bool left;
            Node(int x, int height, bool left)
                : x(x), height(height), left(left)
            {}
            /*
            bool operator < (const Node* node) const{
                if(x != node->x){
                    return x < node->x;
                }
                if(left != node->left){
                    return left ? true : false;
                }
                return height < node->height;
            }
            */
        };

        static bool cmp(const Node* node1, const Node*node){
            if(node1->x != node->x){
                return node1->x < node->x;
            }
            if(node1->left != node->left){
                return node1->left ? true : false;
            }
            return node1->height < node->height;
        }


        vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
            vector<Node*> con;

            for(int i = 0; i < buildings.size(); i++){
                con.push_back(new Node(buildings[i][0], buildings[i][2], true));
                con.push_back(new Node(buildings[i][1], buildings[i][2], false));
            }
            sort(con.begin(), con.end(), cmp);


            map<int, int> hMap;
            map<int, int> xMap;
            for(int i = 0; i < con.size(); i++){
                if(con[i]->left){
                    if(!hMap.count(con[i]->height)){
                        hMap[con[i]->height] = 1;
                    }else{
                        hMap[con[i]->height] += 1;
                    }
                }else{
                    if(hMap.count(con[i]->height)){
                        if(hMap[con[i]->height] == 1){
                            hMap.erase(con[i]->height);
                        }else{
                            hMap[con[i]->height]--;
                        }
                    }
                }
                if(hMap.size() == 0){
                    xMap[con[i]->x] = 0;
                }else{
                    xMap[con[i]->x] = hMap.rbegin()->first;
                }

            }

            vector<vector<int>> ret;
            map<int, int>::iterator iter;
            int lastHeight = 0;

            for(iter = xMap.begin(); iter != xMap.end(); iter++){
                int curX = iter->first;
                int curH = iter->second;
                if(lastHeight != curH){
                    ret.push_back({curX, curH});
                    lastHeight = curH;
                }
            }

            return ret;
        }


        /*
        //way1 use multiset and pair
        vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
            vector<vector<int>> ret;
            vector<pair<int, int>> con; 

            for(int i = 0; i < buildings.size(); i++){
                con.push_back(make_pair(buildings[i][0], -buildings[i][2])); //左坐标高度设置为相反数
                con.push_back(make_pair(buildings[i][1], buildings[i][2]));
            }
            sort(con.begin(), con.end()); //排序后就是按照x从小到大，高度从小到大分布的

            //填入0用于设置ret最后的一个数据， 高度是从小到大的。
            //必须要用curHeights存取目前经过的所有左端点的高度，因为后面这些高度可能成为关键点高度，例如目前的关键点的右端点到了后，前面比当前高度低的矩阵就显示出来了
            multiset<int> curHeights({0}); 
            int lastHeight = 0;  //记录上次的关键点高度

            for(int i = 0; i < con.size(); i++){
                if(con[i].second < 0){//左端点则加入curHeights,重复高度也加入
                    curHeights.insert(-con[i].second);
                }else{//右端点，说明有一个矩形结束了，要从中移除其高度，如果有重复的，只删除其中一个
                    curHeights.erase(curHeights.find(con[i].second));
                }

                int maxHeight = *curHeights.rbegin(); //curHeights中最大值, 即当前的关键点高度

                if(maxHeight != lastHeight){// 当前最大高度如果不同于上一个高度，说明这是一个转折点
                    ret.push_back({con[i].first, maxHeight});
                    lastHeight = maxHeight;
                }
            }

            return ret;
        }
        */
    };
